---
layout: post
title: 学习心得
tag: 技术
keywords: Study
---

从今天开始，把每天的学习的一些知识小结一下~


### 2018-3-27

可以使用`caret-color`来修改input中光标的颜色。

腾讯面试问题：
1. http的状态码，什么情况下会返回304？cache-control和etag，last-modified的区别？  
2. 描述一下css盒模型
3. 实现垂直水平居中有哪些方法
4. 跨域有什么处理方法？JSONP的原理是什么？JSONP可以用post请求吗？为什么？
5. cookie和localstorage有什么区别？
6. vue数据双向绑定的原理
7. react的生命周期有哪些？什么时候会用到componentwillreceiveprops?

>初始化
>constructor
>getInitialProps
>getDefaultState
>componentWillMount
>render
>componentDidMount
>更新过程
>componentWillReceiveProps
>shouldComponentUpdate
>componentWillUpdate
>render
>componentDidUpdate
>卸载过程
>componentWillUnmount

8. let和var的区别
9. 使用过构建工具吗？webpack的loader是干什么的？

### 2018-3-19

前几天看到js位运算，发现有好多可以巧用这个技巧。

1. 按位非 ~-1 === 0

2. 异或来交换数字

```js
  let a = 1, b= 2;
  a = a ^ b;
  b = a ^ b;
  a = a ^ b;

  a // 2
  b // 1
```

关于`for..in`,`Object.keys()`,`Object.hasOwnPropertyNames(obj)`,`obj.hasOwnProperty(prop)`的区别：  
1. for...in会遍历所有可枚举属性，对象从其构造函数原型中继承的属性。
2. Object.keys()会遍历所有可枚举属性，但是不访问其构造函数原型中继承的属性。
3. Object.hasOwnPropertyNames(obj)方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组，但是不会返回其构造函数原型中继承的属性。
4. obj.hasOwnProperty(prop)可以用来检测一个对象是否含有特定的自身属性；和 in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。
5. for...in和obj.hasOwnProperty(prop)搭配筛选后的结果和Object.keys()相同。
6. Object.hasOwnPropertyNames(obj)返回的只比Object.keys()多指定对象的不可枚举属性。

`x = (1, 2, 3)`表达式为Comma operator。  
Comma operator：他表示依次执行括号中的每个表达式，然后返回最后那个结果（返回的是结果，是指，不是reference）。  
如果返回的那个结果是console.log(this)，那么这个this不是执行那个方法，而是undefined。

例子如下：
```js
'use strict'
const fn = function () {
  default () {
   console.log(this)
  }
}

(fn[default])()  // fn
(0, fn[default])()  // this

只有在fn.a()、fn[a]()这样才会被认为是在执行fn的a方法，this才会指向fn，而(0, fn[a])只是返回fn[a]的结果即console.log(this)，而此时this为undefined。在非严格模式下，应该是返回window（全局对象）。
```




### 2018-2-24

在rgb中，red是暖色，green是中性色，blue是冷色，如果r>b,则为暖色，否则为冷色。

在hsv中，`hsv.h >= 60 && hsv.h <= 240`为冷色调，减淡变亮，色相顺时针旋转更暖。`hsv.h <= 60 && hsv.h >= 240`为暖色调，减淡变亮，色相逆时针旋转更暖。

实现深拷贝
```js
        function deepClone (data) {
          let r = null
          if (typeof data !== 'object') {
            r = {}
            for (let key in data) {
              if (data.hasOwnProperty(key)) {
                r[key] = deepClone(data[key])
              }
            }
          } else if (Array.isArray(data)) {
            r = []
            for (let i = 0; i < data.length; i++) {
              r.push(deepClone(data[i]))
            }
          } else {
            return data
          }
        }
```

### 2018-2-6

今天在使用vue的时候发现一个问题，beforeCreate居然在create之后执行，百思不得其解，后来才发现原来在create中的ajax设置了async为false，因为是同步，所以会导致beforeCreate中的loading组件延迟执行。

vue中provide，inject使用。配合vee-validate可以在父组件中对所有使用验证的子组件进行验证。

为什么flex的子元素在设置display为flex后，它的子元素无法撑开它自己。

svg中使用简便的时候，使用d3.area()才渲染下面的面积，如果使用d3.line()会使上扬的线条的上部分渲染。

### 2018-1-16

webpack-dev-server使用，vue模拟数据的配置。

nginx中重写路径：
```js
  location /static {
    if ($http_referer ~* "test\/"){
      rewrite ^(/static\/.*)   /test/$1 break;
    }
    rewrite ^(/static\/.*)   $1 break;
  }
```


### 2018-1-3

今天在给ie调试ajax的时候发现ajax不会发送，[jquery1.5+ ajax跨域请求在IE下没反应](http://www.w3dev.cn/article/20130813/jquery1.5-upper-version-cros-request-in-ie-No-reaction.aspx)

The root route must render a single element 这个异常，这是因为 module.exports（CommonJS） 和 ES6 里的 export default 有区别。

如果你是使用 es6 的写法，并且就是你的组件都是通过 module.exports 导出的，那么在 getComponent 方法里面需要加入 .default。

如果你是使用 CommonJS 的写法，也就是通过 module.exports 导出的，那就无须加 .default 了。

在vue中使用async。

### 2017-12-25

如果是自己手动配置webpack，当你要打包的时候，打包的方式是runtime-only build模式(运行时构建)，这个时候`new Vue`挂载的时候不支持template，只能只能render，如果使用template，就会报错`You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build`。  
[相关链接](https://github.com/vuejs-templates/webpack/issues/215)

因为要给公司开发自用的chrome插件，所以最近肯定要学习不少的内容。就在这几天使用jq的时候，发现很多以前的知识都遗忘了。  
比如要获取radio的checked的属性时，不应该使用attr，应该使用后prop。

对于HTML元素本身就带有的固有属性，在处理时，使用prop方法。  
对于HTML元素我们自己自定义的DOM属性，在处理时，使用attr方法。

给某个name的radio设置checked的value，`$('input[name="radioName"][value="checkedValue"]').prop('checked', true)`

### 2017-12-20

移动端调试工具：debuggap，ChromeDevTools，weinre

### 2017-12-14

浏览器中, js引擎线程会循环从 任务队列 中读取事件并且执行, 这种运行机制称作 Event Loop (事件循环)。  
不仅如此, event loop至少拥有如下两种队列:  
1.task queue, 也叫macrotask queue, 指的是宏任务队列, 包括rendering, script(页面脚本), 鼠标, 键盘, 网络请求等事件触发, setTimeout, setInterval, setImmediate(node)等等。
2.microtask queue, 指的是微任务队列, 用于在浏览器重新渲染前执行, 包含Promise, process.nextTick(node), Object.observe, MutationObserver回调等。

以下是原文：  
>An event loop has one or more task queues. A task queue is an ordered list of tasks, which are algorithms that are responsible for such work as: events, parsing, callbacks, using a resource, reacting to DOM manipulation…

>Each event loop has a microtask queue. A microtask is a task that is originally to be queued on the microtask queue rather than a task queue.

浏览器(或宿主环境) 遵循队列先进先出原则, 依次遍历macrotask queue中的每一个task, 不过每执行一个macrotask, 并不是立即就执行下一个, 而是执行一遍microtask queue中的任务, 然后切换GUI线程重新渲染或垃圾回收等.

### 2017-12-13

cmd中`arp -a`、`ipconfig/all`、`nslookup`

window.requestAnimationFrame方式的应用。

nginx X-real-ip、X-Forwarded-For字段理解：  
`proxy_set_header    X-real-ip $remote_addr` 是设置客户端的ip，如果不设置，经过代理服务器nginx后，web服务器接收到的ip是nginx的ip，并非是客户端的真是ip（如果只隔了1台nginx）。  
`proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for`  意思是增加一个$proxy_add_x_forwarded_for到X-Forwarded-For里去，注意是增加，而不是覆盖，只不过由于默认的X-Forwarded-For值是空的，所以我们觉得是赋值，在中间使用多台代理的时候就会展现不同。$proxy_add_x_forwarded_for变量包含客户端请求头中的"X-Forwarded-For"，与$remote_addr两部分。每次在X-Forwarded-For中增加一个X-Forwarded-For $proxy_add_x_forwarded_for，就可以看成是将接收到的X-Forwarded-For加上自上一台代理或者客户端的ip，逐一传递下来后web服务端就可以接收到从客户端以及各个代理的ip。

[参考资料](http://gong1208.iteye.com/blog/1559835)


### 2017-12-12

parallax.js滚动插件的使用，注意不是parallax这个轻量级的可视化引擎。

srcset的应用场景分析:同一张图片针对不同响应式展现不同精度的格式。

js三种递归方式以及区别：

1.直接调用自身
```js
function a(n) {
  if (n <= 0) {
    return 1
  } else {
    return n + a(n - 1)
  }
}

a(5)   //15
let b = a
b(5)  //15
a = null
b(5)  //error:a is not a function
```
这里就可以看出，b其实是a的一个引用，当a设置为null的时候，b自己也就无法使用了。

2.通过arguments调用自身
```js
let a = function () {}和匿名函数结论相同
function a(n) {
  if (n <= 0) {
    return 1
  } else {
    return n + arguments.callee(n - 1)
  }
}

a(5)   //15
let b = a
b(5)  //15
a = null
b(5)  //15
```
虽然arguments.callee可以调用自身，但是在严格模式下，是禁止使用arguments.callee的。


3.通过函数命名表达式
```js
let a = function f(n) {
  if (n <= 0) {
    return 1
  } else {
    return n + f(n - 1)
  }
}

a(5)   //15
let b = a
b(5)  //15
a = null
b(5)  //15
```
这个方法使用了函数命名表达式来定义函数a。然后在函数内部通过函数名f来调用自身，这样就b和a也就没有任何关系了。他们的指针都指向f函数，在a设置为null后，也只是将修改了a的指针，并没有修改f函数。

### 2017-12-8

之前就研究过exports和module.exports，最近好好梳理下。

module.exports = {}  
这个时候因为module.exports绑定了一个新对象，所以会和原本的exports失去联系，exports不再是module.exports的引用，所以export.xx = xx不会被导出。  
解决办法是`exports = module.exports = {}`，然后exports.xx = xx 还是会被导出。  
这是比较关键的一点。另一个是`exports = {}`这个时候，exports不再是原来的module.exports的引用，所以还是会失去关联。  
若exports和module.exports都以aa.xx = bb的形式赋值，则相互不影响。若有相同的key时，value取后赋值的，不是module.exports赋值的。



### 2017-12-6

js下载文件方法汇总

1.a标签get方式下载

```js  
window.open(url? + params)
```

2.form表单post方式下载

```js
  $('body').append(form)
  form.attr('style', 'display:none')
  form.attr('target', '_blank')
  form.attr('method', 'post')
  form.attr('action', url)
  for (let i in data) {
    let input = $('<input>')
    input.attr('name', i)
    input.attr('value', data[i])
    form.append(input)
  }
  form.submit()
  form.remove()
```

3.blog方式下载

```js
配合downloadjs一起使用

axios({
  method: 'post',
  url: url,
  data: data,
  responseType: 'blob',
  headers: {
    'Accept': 'application/vnd.openxmlformats-officedocument' + '.spreadsheetml.sheet'
  }
})
.then((res) => {
  download(res.data, 'test1.xls')
})
```

### 2017-12-5

```js
for (const prop in obj) {
  if (obj.hasOwnProperty(prop)) {
    console.log(`obj.${prop} = ${obj[prop]}`);
  } 
}

// for in 会循环继承的属性，而hasOwnProperty则会忽略继承的属性
```

### 2017-11-20

怎么在vue中修改echarts的tooltip框的大小宽度，因为tooltip框是一个echarts自动生成的div，而他的样式都是行内样式，所以直接通过改变tooltip的样式是比较麻烦的，比较轻松的一种方式是通过`formatter`来实现。  
因为formatter可以返回一个div，所以我们可以通过params得到图表的name等别的参数，然后显示在div，通过给div一个class，然后设置css来实现tooltip的换行已经宽度控制，当然如果在vue中使用的时候要格快注意取消css的scope属性。

### 2017-10-27

在vue遇到`Do not use 'new' for side effects`，可以在这函数头顶上加一句`/* eslint-disable */` 。

删除html中的标签，删除空格，删除换行的正则匹配：  
`text.replace(/<.*?>/ig, '').replace(/(^\s*)|(\s*$)/g, '').replace(/(\n)/g, '')`

### 2017-10-18

当vue使用history的router模式后，如果你想打包完看打包之后的项目，需要配置相关服务器配置，这是因为vue是单页面应用，而history在跳转的时候会直接跳转到另外一个网页，而不是当前的单页面，所以会出现index可以打开，但是跳转别的页面的时候会出现not found，这是因为route在这里无法被识别。所以需要配置相关的服务器。

在官网中有好几种方式，我试了下node的，发现并不好用，因为他每次返回的content-type都是text，这就导致获取到的js文件也是text类型，然后就会出现`unexpected token >`这个错误。

然后我尝试使用expredd搭配`connect-history-api-fallback`中间件这个方法，一开始也是有点摸不到头脑，连主页都是not found，后来在[issus#35](https://github.com/bripkens/connect-history-api-fallback/tree/master/examples/static-files-and-index-rewrite)中找到了答案，原来在使用这个中间件的时候，还要配置默认的静态文件和index跳转路径。

具体代码:
```js
  var history = require('connect-history-api-fallback');
  var express = require('express');

  var app = express();
  
  // 这里指向你的index.html文件目录，第一次使用的时候是为了让中间件获取主要的静态文件请求
  app.use(express.static('./'));

  app.use(history({
  }));
  
  // 第二次使用时为了让中间件重写请求，如果这里不添加的话只会显示主页，跳转别的页面的时候就会出现not found
  app.use(express.static('./'));

  const port = 5000;
  app.listen(port, () => {
    console.log(`Example app listening on port ${port}!`);
  });
```




### 2017-10-13

在使用swiper的时候遇到了很多问题，首先是如果遇到页面进去不自动播放的话，先设置observer和observeParents为true，还不行的话就看看this.swiper.autoplayPaused是否为true，如果为true则设置为false，然后在`this.swiper.init()`一下就会自动播放了。至于点击之后不自动播放那就需要设置autoplayDisableOnInteraction为false。

`centeredSlides`可以让图片居中显示。

由于移动端和pc端还是有蛮大的差别，首先移动端不常用px，很多是以rem为单位。



### 2017-9-22

UMM!~~好久没写了~还是照旧总结下最近新获取的到的一些内容~

1. 在bootstrap的弹出框中看到可以点击弹出框外的部分实现弹出框关闭，vue中就是在created中给document.addEventListener中绑定一个函数，让弹出框的disable为true，然后给弹出框的div绑定一个click，`event.stopPropagation()`即可。
2. 最近的新项目比较大，然后数据接口全由前端来设计，虽然这对前端是好事，但是事情也多了不少了，接口对接文档写的头疼，特别是需求改了之后部分接口数据接口都变了，不过我发现写这个还是蛮有趣的，挺锻炼人的~
3. 在关于vue中组件化的区分，如果父组件和子组件之间联系很大的话，比如子组件的渲染很大程度的依靠父组件各个数据，那么组件化的过程中可以主要的把css等样式组件化出去，js等方法还是写在父组件中，但是如果是子组件自己的方法的话还是应该写在子组件中的script中。
4. 虽然每天写代码，但是我发现其实自己的基础还是掌握的不好，很多基础的api还是需要去翻文档，不翻就写不出来，所以现在每天都会把基础的知识写在小本子上，平时的时候多翻翻。
5. transition不能应用在display的变化上。
6. 如果不想使用table，但是又想使用table的那些布局，那么可以给div设置display为table-row和table-cell来实现行和列的效果。
7. 如果在table想让table的tbody出现滚动条，而thead保持不动，我发现实在是没什么好办法，虽然很多人说给tbody的tr和thead添加display为table，但是当tbody的display设置成block之后tbody和thead就已经不联动了，如果你的table的th和td都是固定的，那还是可以显示那个效果，但是如果你的th和td都是联动的，th的宽度和会根据td的宽度而改变的时候这时候这个方法就不适用了。所以这个时候只能通过js获得每个td的宽度，然后分别给对应的th设置宽度。


VeeValidate的使用，在main.js中引入VeeValidate，然后设置config，再`Vue.use(VeeValidate, config)`即可，你可以将需要验证的表单内容写在main.js中，也可以写在各自的组件中，只要在created中定义好表单信息，然后`updateDictionary`一下，比如：

```js
  const dict = {
    zh: {
      custom: {
        user: {
          required: '用户名不能为空'
          },
          password: {
            required: '密码不能为空'
          }
        }
    }
  }
  this.$validator.updateDictionary(dict)
```


使用vue自带的dev-server.js写接口，比如： 

```js
  // api.js文件的内容
  let path = require('path')
  let api = {
    'api/url': path.resolve(__dirname, 'data/data.json')
  }
  module.exports = api


  // 在der-server.js中引入接口api的文档
  let api = require('../mocking/api')


  //遍历api中每个对象 
  Object.keys(api).forEach(function(url) {
  app.get(url, (req, res) => {
    fs.readFile(api[url], 'utf8', (err, data) => {
      if (err) return console.log(err)
      let json = JSON.parse(data)
      res.json(json)
    })
  })
})
```
你将需要的数据写在json文档中，这样当你写好接口文档的时候，就不需要等到后端接口写好才去测试，自己可以边开发边测试接口数据。post的类似，不过需要一些node.js知识来判断传过来的数据。  







### 2017-8-11

在学习node的时候把node更新到了8.3.0，结果之前的几个用了sass的项目打不开了，原因貌似是因为依赖的node版本改变，我npm rebuild node-sass后发现还是不行，就下了一个nvm解决了。使用node.js的时候用8.3.0，不然就切换会6.10.1。

### 2017-8-4

使用scss的时候记得安装相应的包:  
`npm install sass-loader node-sass vue-style-loader --D`  
然后再style中加入`lang="scss"`

只有设置了prototype的对象可以查看prototype，不然不可查看。

构造函数new出来的对象的constructor会随着原型的改变而改变。如果原型没有改变，constructor就指向构造函数，如果原型改变，则constructor则指向修改后的原型的constructor。

理解js中的replace函数用法：  
当第二个参数是函数的时候，他会给函数传递几个参数，matchStr,groups,index,sourceStr，其中groups根据正则中分组的情况增加，有两个分组就会传递matchStr,group1,group2,index,sourceStr。  
matchStr: 每次正则匹配到的字符串，这是固定的;  
groups: 代表的是group1,group2,group3......等等参数。参数个数根据捕获组的个数来定。  
index: 匹配项在字符串中的开始下标;  
sourStr: 原字符串。


### 2017-8-2

今天看了十年踪迹在清华大学演讲的ppt，看到他用了很多的高阶函数，使用它的目的是write less, do more！所以在今天也学习了很多简单高阶函数的用法！

第一次看到高阶函数的时候，比较感觉困惑的是参数的定义，当最外层函数传入一个参数的时候，内层函数再传参数那参数到底是怎么层层调用的呢，然后输出函数又是怎么再内层函数中调用，以及一系列的问题。现在来总结一下：

比如这个例子：
```html
<ul>
  <li>1</li>
  <li>2</li>
  <li>3</li>
  <li>4</li>
  <li>5</li>
  <li>6</li>
  <li>7</li>
  <li>8</li>
  <li>9</li>
</ul>
```
```js
function batch(fn){
  return function(target, ...args){
    if(target.length >= 0){
      console.log("11")
      return Array.from(target).map(item => fn.apply(this, [item, ...args]));
    }else{
      return fn.apply(this, [target, ...args]);
    }
  }
}

function queriable(fn){
  return function(selector, ...args){
    if(typeof selector === 'string'){
      selector = document.querySelectorAll(selector);
    }
    console.log(...args)
    return fn.apply(this, [selector, ...args]);
  }
}

function pack(map){
  return function(el, obj){
    for(let key in obj){
      map[key].call(this, el, obj[key]);
      console.log(obj[key])
    }
  }
}

function setColor(el, color){
  el.style.color = color;
}

function setFontSize(el, fontSize){
  el.style.fontSize = fontSize;
}

let css = pack({color: setColor, fontSize: setFontSize});
css = queriable(batch(css));

css('ul > li:nth-child(2n + 1)', {color: 'red'});
css('ul > li:nth-child(3n + 1)', {color: 'green', fontSize: '22px'});

```
<iframe src="https://code.h5jun.com/gelo/2/edit?js,output" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 400px; height: 400px;"></iframe>


刚开始看到这个的时候我是比较困惑的，到底是先执行css，再batch，还是先queriable再batch，所以我在每个函数中打log，打每个的args等参数，了解到函数都是从外到内运行，即queriable到batch再到css，然后参数都是通过函数内置的arguments来传递。

其中那个pack函数我整整理解了很久才领略到高阶函数的魅力，他的确能够用更少的代码做更多的事，虽然难度比较大，也不好理解。

以及这个应用了ramda.js的例子：

<iframe src="https://code.h5jun.com/vipi/2/embed?js,output" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 400px; height: 400px;"></iframe>

最开始我并不是很理解函数柯里化，但是当我理解了这个例子中changeColorTo函数后，我不禁感叹函数柯里化的强大，而对于ramda.js这个库，阮一峰老师的这篇博文也说的很棒[这里](http://www.ruanyifeng.com/blog/2017/03/ramda.html)。

```html
<div id="students"></div>

<button id="printBtn">print</button>
```

```js
class Component {
  constructor(id, opts = {data:[]}){
    this.container = document.getElementById(id);
    this.options = opts;
    this.container.innerHTML = this.render(opts.data);
  }
}

class StudentViewModule {
  constructor(view){
    this.view = view;
    this.nameEl = view.querySelector('.student-name');
    this.ageEl = view.querySelector('.student-age');
    this.ageEl.onchange = function(evt){
    this.age = evt.target.value;
    }
  }
}

// 这里使用defindProperty是因为要双向绑定，不然可以直接在class StudentViewModule中设置name和age
Object.defineProperty(StudentViewModule.prototype, 'name', {
  set(val){
    this.nameEl.innerHTML = val;
  },
  get(){
    return this.nameEl.innerHTML;
  }
})

Object.defineProperty(StudentViewModule.prototype, 'age', {
  set(val){
    this.ageEl.value = val;
  },
  get(){
    return this.ageEl.value;
  }
})

class Students extends Component{
  constructor(id, opts = {data: []}){
  // super()是新建父类的this对象，但是this还是指向子类，所以这里调用父类的constructor的方法，其中的this指向子类，
  // 所以父类的constructor方法中的this.render不会报错，因为this指向子类。
    super(id, opts);              
    this.bind();
  }
  render(data){
    let content = data.map(student => `
      <li class="student-info">
        <span class="student-name">${student.name}:</span> 
        <input type="text" value="${student.age}" class="student-age"/>
      </li>
    `);
    return `<ul>${content.join('')}</ul>`
  }
  bind(){
    let students = this.container.querySelectorAll('li.student-info');
    let data = this.options.data;
    let info = [];
    students.forEach((student, i) => {
      info[i] = new StudentViewModule(student)
    });
    this.studentInfo = info;
  }
}

let data = [
{
  name : '张三',
  age: '27'
}, 
{
  name : '李四',
  age: '21'
},
{
  name : '王五',
  age: '22'
},
{
  name : '赵六',
  age: '23'
}
];

var studentList = new Students('students', {data});

printBtn.onclick = function(){
  // 这里studnetList中调用了new Students,他在bind()中设置了studentInfo，这里的student是studentList.studentInfo的每个对象
  console.log(studentList.studentInfo.map(student => {
    return [student.name, student.age]
  }))
}
```

这是一个双向绑定的例子。

不得不说，今天的收获满满，虽然没做什么，但是感觉对js的理解更深了一步。




### 2017-8-1

`alert(1 && 2)`会输出2，知道这是为什么吗？

在使用object.defineProperty的时候要注意descriptor的定义。

```js
//调用Object.defineProperty()方法时，如果不指定
var someOne = { };
someOne.name = 'coverguo';
console.log(Object.getOwnPropertyDescriptor(someOne, 'name'));
//输出 Object {value: "coverguo", writable: true, enumerable: true, configurable: true}

//直接在对象上定义的属性，这个特性默认值为为 true
var otherOne = {};
Object.defineProperty(otherOne, "name", {
    value:"coverguo" 
});  
console.log(Object.getOwnPropertyDescriptor(otherOne, 'name'));
//输出 Object {value: "coverguo", writable: false, enumerable: false, configurable: false}
```


### 2017-7-27

如果是对整个子组件应用vue过渡效果的时候，由于没有设置position，它在进入和消失的时候会闪屏，因为他消失好像是从上往下，我应用的时候由于顶部有个black的bar，所以看起来特别明显。但是设置了position后就没有这个闪屏的效果了。

### 2017-7-26

在vue中使用addEventListener的时候，不要直接绑定在body上，这样多次绑定同一个函数的话不会被覆盖，应该覆盖在相应的组件上，可以用`$.el`来获取当前的组件。

使用v-html插入html的时候，如果当前组件的css是scoped的，那么插入的html不会被css渲染，解决方法就是不要设置scoped属性。

vue不会监测到一个对象新属性的增加与删除，解决方法是使用`vm.$set(target, key, value)`和`vm.$delete(target, key)`。

mixins选项可以接受一个混合对象的数组。这些混合实例对象可以像正常的实例对象一样包含选项,他们将在`Vue.extend()` 里最终选择使用相同的选项合并逻辑合并。Mixin钩子按照传入顺序依次调用,并在调用组件自身相同的钩子之前被调用。比如mixins里的created()钩子在实例的created()前调用，但是mixins的mounted()钩子在实例的created()钩子之后调用。

使用directives指令的时候，由于传入的参数只能是可读，当你要修改传入的参数的时候，使用dataset来修改。dataset可以绑定data中的变量，但是在directives中修改dataset值的时候发现，他只能修改所绑定el的dataset的值，但是不会同时修改data中dataset所绑定的变量的值。比如：

```js
<div v-a :data-name="bb">2222</div>

data () {
  return {
    bb: '22'
  }
}
directives: {
  a: {
    bind (el) {
      console.log(el.dataset.name)   // '22'
      console.log(el)     // <div v-a data-name="22">2222</div>
      el.dataset.name = 'bbb'
    }
  }
}

// <div v-a data-name="bb">2222</div>
执行完函数后发现div中的data-name等于bbb,但是data中的bb还是等于22。
```

### 2017-7-24

因为要短时间重写jsp老项目，只能暂时用iframe来代替jsp的include，在使用iframe的时候发现获取不到页面滚动条的数值，最后自己再看window.parent的时候发现可以在`window.parent.document.scrollingElement`中获取scrollTop。

```js
function totop() {
  var scroll_top = window.parent.document.scrollingElement;
  $(scroll_top).animate({
  scrollTop : '0px'
  }, 400);
}
```

### 2017-7-19

除了使用chrome的web server扩展可以开本地服务，也可以使用npm的serve来开启服务，他的端口自动设为5000，如果占用了就往上加。

### 2017-7-13

windows下全局安装mocha的时候发现无法安装，主要是没有管理员权限，解决方法是以管理员权限运行cmd，再进行全局安装。

设置node.js的全局安装路径：打开git，输入`npm config ls`，修改prefix的值，`npm config set prefix "xxxxxxxx"`就ok了。

关于istanbul这个代码覆盖率工具，如果是在window上和mocha一起使用的时候，要注意不能直接打`istanbul cover _mocha`这个代码，因为window的路径问题，要使用`istanbul cover node_modules/mocha/bin/_mocha`,这个在官方说明上usage on windows也有提到。

学习了一些makefile文件的配置，不过因为在window系统上，所以刚开始使用的时候还是很懵比，怎么也用不了make。后来在`http://sourceforge.net/projects/mingw/files/latest/download?source=files`上下载了GNU编译器，然后在后面的界面中选择基础配置和C++编译器，将MinGW安装目录下的bin中的mingw32-make.exe重命名为make.exe。接着就可以使用make指令了，网上有说要配置系统变量，不过我没配置好像也可以运行。之后我在git上尝试使用make，但是始终告诉我make commend not found，配置了用户变量也是提醒这个错误，我也不知道这个是什么原因0.0。

### 2017-7-5

今天又遇到给后台传参要传数组的问题，发现还是不好传，所以以后还是直接传json对象比较好。今天还遇到表单提交的时候需要另外提交字段，如果后台用了spring，解决方法是接受的时候增加一个参数来解析文字。

今天在使用vuex的时候发现，如果跳转的使用的是`window.location.href`，那么vuex中store保存的信息都会清空，这是因为`window.location.href`会刷新页面。所以在vue中需要跳转的时候最好是用`this.$router.push()`来进行跳转。

### 2017-7-4

一看发现好久没写心得了，最近也比较忙（其实都是借口，就是懒），今天电话面试了一家公司，感觉自己还不错，虽然有些问题没答上来，以及在厕所不敢大声说话。这次面试也学到了蛮多东西，主要是一些js基本的应用概念，太久没写原生js了，发现自己有点忘了，还是要常常温故，之前拉下的js高级教程的笔记也要开始补起来了。今天被问到一些ie8兼容性，MVVM,MVP,MVC框架的区别等等，以前都记过但是忘了，今天重新记下笔记：
1. ie8关于json的兼容性，因为ie8不兼容JSON.parse()的解析方法，所以可以使用eval()方式，不过比较危险，因为eval()在解析的时候会执行字符串中的代码。关于转成字符串，一个比较有趣的方式是将JSON.js改名为JSON2.js，然后调用JSON2.stringify()。
2. MVC框架是最早提出的，用户操作->View（负责接收用户的输入操作）->Controller（业务逻辑处理）->Model（数据持久化）->View（将结果反馈给View）。MVP是把MVC中的Controller换成了Presenter（呈现），目的就是为了完全切断View跟Model之间的联系，由Presenter充当桥梁，做到View-Model之间通信的完全隔离。如果说MVP是对MVC的进一步改进，那么MVVM则是思想的完全变革。它是将“数据模型数据双向绑定”的思想作为核心，因此在View和Model之间没有联系，通过ViewModel进行交互，而且Model和ViewModel之间的交互是双向的，因此视图的数据的变化会同时修改数据源，而数据源数据的变化也会立即反应到View上。  
通过这一段话可以看出MVVM框架比较重要的进步是关于数据的控制，双重绑定保证了数据的一致性，而且在获取数据上也比通过dom操作简单很多。
3. 关于vue的数据渲染逻辑：自定义Render函数，template写法，el写法。不过基本都是用template。
4. Vue中v-bind和v-on的区别，v-bind绑定的是变量，v-on绑定的是方法，虽然知道怎么用但是一时间却说不上来这个。


现在总结一下这半个月学到的一些东西：  
1. 深层次的了解了js中的运算机制，比如`++[[]][+[]]+[+[]] = 10`，`(1+{})[4]= j`等等（详见justjavac博客）
2. 公司新项目的开发，其中用到了一个集合input和select功能的div，就是能用够像select一样进行下拉列表展示，也可以在select框中手动输入数据，并自动filter，主要的思路就是使用一个div，下面包裹一个ul列表用来展示下拉列表。
3. 学习了es6的编码规范
4. 在使用JQuery的时候，注意使用变量的时候使用单引号将字符串隔开

昨天在听了部分justjavac的知乎live中的前端工程师的入门与进阶，我总结几个要点：
1. 前端工程师也还是程序员，所以必须要写出比较好的代码，好的代码包括，代码的很强壮，比较容易维护，逻辑条理清晰
2. 在学习新的框架的时候也不能忘了js，css等基本的东西，很多人都是学习了3个月的知识，然后重复使用了好多年，即使有多年经验，但是知识还是那么多

等有空我单独写一篇心得0.0


### 2017-6-20

毕业典礼请假了半个多月，感慨很多，今天回来上班，那就好好工作学习。那么今天呢，主要学习了关于前端反向代理跨域来调用后端的接口，从而获得数据。

一开始我使用的是ngnix，在配置ngnix的时候我也遇到了一些问题：
1. 当修改了配置文件的时候，ngnix -reload不管用，需要先ngnix -quit，在start ngnix。
2. ngnix监听的端口不能与项目的端口一样，会产生冲突。我一开始使用的是vue的的8080端口，而ngnix的端口是80，所以一直显示404。
3. ngnix的location有两种写法，一种是rewrite，一种是直接在标记的代码结构前添加请求的网址。相比较后一种直接添加的比较方便。

因为使用了vue，如果在项目外重新开ngnix的话，ngnix就监听不了vue的项目了，后来发现vue-cli本来就有反向代理这个功能，就是在config中的index.js，proxyTable这个字段，适用方法如下：
```javascript
proxyTable: {
  'api': {
    target: 'your url',
    changeOrigin: true
  } 
}
```
当你在页面中调用api/aa的时候，返回的数据就是your url/api/aa接口的数据。

当然proxyTable也有rewrite的功能。
```javascript
proxyTable: {
  'api': {
    target: 'your url',
    changeOrigin: true,
    pathRewrite: {
      '^/api': 'bb'
    }
  } 
}
```

这样你在页面中调用api/aa的时候，返回的数据就是your url/bb/aa接口的数据。

### 2017-5-25

在知乎上看到一个话题，有个公司面试了一个5年经验的前端，结果那个面试者答不上原型链的基础知识，张口闭口就是vue，react等框架的实现原理等等，看着评论，大家的反应都不太一样，很多人说面试官要会发现面试者的优点，但是也有很多一批人说连js基础的知识了解的都一知半解，说句实话，感觉如今人们被工具支配的太恐怖了，以至于有了工具却不去了解基础知识了。我在平时的学习中一定要打好基础，努力加油。下面是哪个面试官出的一道题目：

输入m,n，生成一个长度为m的每个数都为n的数组，如果不能用循环，可以使用递归：
```
function t3(m, n) {
  var arr = arguments[2] || []
  if (m > 0) {
    arr.push(n)
    t3(--m, n, arr)
  }
  return arr
}
```
或者使用`new Array(m+1).join('n')`，不过递归的方法没有循环来的性能高。

arguments对象存储的是实际传递给函数的参数，而不局限于函数声明所定义的参数列表，而且不能显式创建 arguments对象。

### 2017-5-11

今天在用vue获取ajax请求的数据的时候发现一个问题，当我在created发出ajax请求来获取数据，在template中调用的时候，会报错，原因是因为当我调用的时候，数据还没有请求到，所以会出现undefined的现象，解决方法是在请假数据的外面包一个div，`v-if="数据"`，这样当数据不存在的时候便不会执行下面的代码，当数据请求到了，会自动更新。

### 2017-5-10

如果要给后台传json字符串的话，比如ajax中的请求是`data: Data`，Data是json字符串，那么需要在ajax中添加这句话，`contentType: 'application/json; charset=utf-8'`，告诉服务器，我给你的json字符串，不然可能会出错。但是如果json字符串是写在data的对象里的话，则不需要写那句话，如：`data: {jsonString: Data}`。

### 2017-4-26

try-catch语句中如果后面跟着finally子句，那么无论try还是catch语句中的return语句都被毁忽略。finally语句一定会被执行。


### 2017-4-21

因为vue中的 &#123;&#123;&#125;&#125; 是文本插值，所以data中的'\n'是不会再html中换行的，不过可以在换行的地方使用`<br>`进行换行，用jq的html()显示


### 2017-4-19

当使用bootstrap的时候，如果子元素设置了margin-top，父元素没有clearfix的话，可能会出现子元素的margin-top应用在了父元素上，即父元素有了margin-top，而子元素还是和父元素紧紧的依靠在一起，解决方法是给父元素clearfix，出现这个的原因是bootstrap中有自带的默认float属性。

### 2017-4-17

在vue中使用datetimepicker插件的时候，因为这个插件是依赖jq的，所以在使用这个插件的时候在先引入Jq，第一种方法在index.html中引入jquery.js，在webpack中加入全局变量$
```javascript
externals: {
    jquery: 'window.$'
  }
```
,然后再index.html中引入插件的js文件，在vue组件中require jq，`var $ = require('jquery')`,就可以使用了。  
第二种方法是在index.html中引入jq文件，然后再vue组件中import插件的js，再require jq，`var $ = require('jquery')`，就ok了


### 2017-4-10

当使用CSS3的nth-child()的时候，千万要记住body是html的第二个子元素，所以nth-child(2)会应用在body上。

CSS的样式优先级：
内联样式 > 内部样式 > 外部样式。  
1. JQ的addClass是在外部文件或者内部样式中定义好的。
2. JQ的.css()是直接通过元素的style属性附加到元素上，属于内联样式。

所以.css()的优先级会高于addClass，当你使用JQ实现点击、hover样式转变的时候，最好使用addClass不容易出错。

### 2017-4-6

word-wrap和word-break的区别：word-wrap是用来决定单词内要不要断句，word-break是用来决定怎么样断句。共同点就是当一个单词过长超过包裹的父级元素的宽度的时候，会另起一行，将单词断开。但是不同点是，word-wrap会先另起一行，即将那个很长的单词另起一行显示，当那个单词太长一行都放不下的时候，再断开。但是word-break不会另起一行显示那个单词，而是接着前面的单词，当那行剩余的部分包裹不了的时候再换行。所以word-break比较节省空间。


### 2017-3-25

页面使用border创建一条线，怎么让它在div中竖直方向居中，除了用了position,，可以使用margin


### 2017-3-23

这几天学习了vue.js

在methods中调用ajax的时候，一开始的this指向vue实例，但是success中的this指向success这个方法，如果要在success方法中调用vue实例中的数据，可以在ajax开头`var self = this`，那这个self就是vue实例。


### 2017-3-17

position:fixed始终以body为父级元素，所以当height为100%的时候就会覆盖整个页面，用来整页修改css很有用。

### 2017-3-15

今天遇到了一个问题，在写项目的时候发现动态生成的48个表单中，有一个表单的样式不对，然后今天自己就好好使用断点来查找问题，最后发现是传回来的数据的末尾是/，然后和&gt;形成了闭合，所以产生了两个tr。所以以后再使用js动态添加节点的时候，最好值和&gt;之间空一个空格，就可以避免这个问题，然后，虽然这个问题很小，但是我比较算正式的使用了断点这个功能，感受了他的魅力！


### 2017-3-13

今天遇到一个错误，显示Uncaught SyntaxError: Unexpected token o in JSON at position 1  
查了一下资料，原因是接收到的json已经是对象了，所以不能再使用JSON.parse()将之转换成对象。  


### 2017-3-10

项目基本写完了，这几天都在看JavaScript高级程序设计，看了BOM,DOM,客户端检测，感觉看的晕乎乎的，没有前面几章看到有兴趣，也许是因为这几张比较侧重实例，不过自己还是要好好啃完它，啃完就要准备开始学习vue了。


### 2017-3-8

昨天和今天主要在为原来的项目增加可爬的数据类型，其中有好几种很复杂的数据，数列对象各种包，这里写几个遇到的一些麻烦。

1. input end不规范基本是因为{}没有断好。  
2. 不要使用if，if，else。应该使用if，else if，else。  
3. 注意input和textarea。  
4. 如果对象的属性是变量的时候，需要使用obj[]来获取属性，必要的时候自己来构建一个str。比如：str="[parma"+1+"]",obj[str]。这里的str=[parma1]。
5. 在写ajax的时候，如果data是一个json对象，可以在赋值的时候直接添加到data里，也可以全部赋值完后统一定义data。
6. 使用JQ通过变量来获取某个节点的值的时候，不能直接$(name div)，应该使用find，parent等方法来获取。
7. 注意使用return false的后果。如果在循环中使用return false会直接种植循环。其次，return语句只能在函数中使用，起的地方使用会报Illegal return statement错误。
8. 使用Object.getOwnPropertyNames(a).length可以获取对象，数组的长度。

### 2017-3-6

写完项目的所有接口，用了很多数组的方法，也在js写了很多动态创建html的代码，从刚开始的不会使用++到现在的比较熟练，感觉还是学到了很多。


### 2017-3-4

今天写了分页，动态的获取数据库里的信息，发现一开始自己写的太复杂，其实写起来很简单，也学到了怎么通过this获取this里面的span的内容。
```javascript
$('>span',this).text()
```




### 2017-3-2

今天遇见输入input时只要点击空格键就会自动提交并刷新表单，解决方法是：
```javascript
$("input").keydown(function(event){
     if(event.keyCode==13)return false;
    })
```

这里的keyCode==13是代表回车键。

使用了confirm()，在confirm()中二次使用ajax。

优化了项目中获取数据的表达式，感觉以后自己再写代码的时候要多注意代码的质量，考虑到可维护性，以及算法的优化。




### 2017-3-1

split(),join()用来数组和字符串的转换

学习了BOM，window对象，了解了window.location对象，并使用了其中的href和search的用在了自己的项目里。  
使用了window.open(),window.location.href等等。





### 2017-2-28

JQ: focus()方法相当于Javascript中的onfoucs()方法，作用是处理获得焦点的事件。    
    blue()方法相当于Javascript中的onblur()方法，作用是处理失去焦点的事件。    
    offset()方法是获取元素在当前视窗的相对偏移。  
    scrollTop()和scrollLeft()方法是获取元素的滚动条距顶端的距离和距左侧的距离。这两个方法也可以指定一个参数，控制元素的滚动条滚到到指定位置。





### 2017-2-27

JQ的选择器，了解了选择和筛选的区别，children()是筛选子元素的，不会考虑其他后代元素，空格是选择后代的，&lt是选择子元素的。

next()用于取得匹配元素后面紧邻的同辈元素。  
prev()用于取得匹配元素前面紧邻的同辈元素。  
siblings()用于取得匹配元素前后的所有同辈元素。(ps：这个函数很有用，可以用来点击按钮的时候改变class)  
closest()方法用于取得最近的匹配元素。

```javascript
$("#CrawlerTable").delegate(".c-start","click",function(){
    var startId=$(this).parents("tr").attr("id");
    $.ajax({
      type: "POST",
      xhrFields: {
          withCredentials: true
      },
      crossDomain: true,
      url:dataUrl+"/SpyderPlatform/spyderInfo/start",
      dataType: "json",
      data:{
        id:startId
      },
      success:function(data){
        if(data.result == true){
          alert("启动成功");
          window.location.reload
        }else{
          alert("启动失败或者已经启动");
        }
      }
    })
  })
```
这里的xhrFields的是用来设置本地XHR对象的"名-值"映射，可以在需要时设置"withCredentials"为true二人执行跨域名请求。  
而crossDomain为true为跨域请求，false为同域请求。



### 2017-2-23

ajxx的基本格式：

```javascript
$('#mysave').click(function(){
            $.ajax({
                type:"POST",
                url:{},                
                datatype:'json';
                async: false,
                error: function(request) {
                    alert("Connection error");
                },
                success: function(data) {
                    $("#").parent().html(data);
                }
            })
        })
```

这里的data是发送到服务器的数据，如果不是字符串，将自动转换为字符串格式。可以想要防止这种自动转换，可以使用processData选项。  
dataType是预期服务器返回的数据类型，如果不指定，JQuery将自动根据HTTP包MIME信息返回responseXML或responseText,并作为回调函数参数传递。可用的类型有：xml,html,json,script,jsonp,text。


 jQuery 中bind(),live(),delegate(),on()区别,点击[这里](http://blog.csdn.net/hi_kevin/article/details/37757657).

 今天在写项目的时候由于需要动态的创建文本，而文本里面有一些按钮来控制动态效果，如果只用click，bind事件来绑定这几个按钮的话，会发现浏览器没有报错也没有执行，查了资料请教了主管后才之后这个时候需要使用deligate()方法，deligate()方法可以绑定未来的元素，比如脚本新创建的一些元素，而live()和deligate()的原理相同，只是live()是绑定到元素上，而deligate()可以通关过父级元素绑定到子元素。live()方法已经在JQ1.7版本被弃用，所以最后不要再使用，而以上的方法都是通过on()方法来实现，所以on()是万能的。


### 2017-2-22

margin-top,margin-left,margin-right,margin-bottom 是body中的属性  
th,td 是表格的元素,与之对应的是  
padding-top,padding-left,padding-right,padding-bottom,以及 vspace,hspace,cellspacing,cellPadding=0
等元素

今天学习了input框的一些属性：placeholder，required等，还有一个label的for，配合input的id使用。

JQ的clone()，index()，attr()，find()，after().

clone()可以解决一些需要动态创建相同格式的html元素。

index()这个函数也很有用，比如当我们点击一个按钮的时候，如果这类按钮有很多个，但是我们需要知道这个按钮的index，比如点一个按钮，然后会使包裹他的父级div消失，因为都是同时出现的，只有合理的设置好class，这个时候我们就可以通过按钮的index来得到div的index，从而操控，但是如果我们要自己写，思路就是点击这个按钮的时候，最关键的就是得到这个按钮的index，但是如果我们用普通的js来写就会有点麻烦，因为要得到按钮的index，你首先需要遍历所有的这类按钮，然后给每个按钮一个index，比如btn.index = i ; 然后再次循环给每个按钮一个click事件，但是如果第二次循环给按钮一个click事件，那当我们点击这个按钮的时候就不会触发这个click函数，所以这时候我们就需要index()这个函数来写。

就可以通过index()解决。  
```javascript
	$(document).ready(function(){ 
	$(".Element").click(function(){        //添加按钮元素
	   alert($(.Element).index($(this)[0]));
	   })
	}) 
```


### 2017-2-18

这几天学了一点vue.js，推荐一个比较轻松愉快的入门博客，点[这里](http://www.cnblogs.com/keepfool/p/5619070.html).

### 2017-2-15

轻松愉快的一天！一天都在面试，所以晚上放松一天，明天继续努力学习！（晚上找了一些之前几个问题的答案，已附上）

oh my god~!

刚才遇到了被占用端口的问题，通过[这个](http://www.cnblogs.com/lxconan/p/who-is-using-my-port.html)才了解

原来也是我的福昕阅读器占用了我的端口~
 
### 2017-2-14

今天是情人节哟，不知道小伙伴们都有没有人陪，我今天又在图书馆呆了一天，今天学习了原型的继承，函数表达式，因为明天的面试，略微的看了xml，json和ajax技术，没有足够的时间让我准备心里还是有点难过的，晚上具体的看了些ajax的代码，希望明天面试顺利，加油！



### 2017-2-13

今天在图书馆泡了一天，收获的不是一般的多，看了很多js的书，大概写了以下一些问题。

1. 正则表达式的概念
2. 创建数组时用new和不用的区别
3. new操作符在js中的意义
4. 如何提升js的性能
5. 函数声明，函数表达式的区别，以及一些扩展（声明提前，变量提前）
6. URL和URI的区别

好了，现在来一个个的解决。

正则表达式的含义我用一张图来解释。

<p><img src="/public/tech/Study/regex.png"></p>

关于创建数组时用不用new需要知道两个概念，就是栈对象和堆对象，在JS高程里面的第119页详细的介绍了，如果用new来创建一个新数组的，那这个数组就是属于堆对象，他不会自动销毁，需要手动释放否则可能会出现内存泄露。如果不用new的话，那这就是一个栈对象，这个只存在一行代码的执行瞬间，然后立即被销毁。

new操作符在js中的意思，当用new操作符创建一个空对象时，this指向该空对象，而且这个对象会继承原函数的原型，属性和方法也会加入到this引用的对象中。新创建的对象由this引用，并且最后隐式的返回this。

如何提升js问题，我发现一个比较不错的博客，推荐给大家，点[这里](http://www.chinaz.com/web/2015/0626/417391.shtml)。

函数声明，函数表达式的区别其实很简单，就是函数声明的话函数名和函数体会提前，他属于那种随叫随到的，只要你需要了，我就到了。而函数表达式不会提前，他是属于那种只有你到我这里了，你才能见到我，不然休想。再翻其他资料的时候，也看了很多关于变量提前，以及关于这三者混合出现的一些情况。  
这里简单的说下当变量声明和函数声明同时提升的时候（变量名和函数变量名相同），函数声明会覆盖变量声明，即最终那个变量显示的结果以函数为准，这个是变量声明而不是变量赋值。其中这个有一道比较好的题目，如果理解了这个应该对这几个名词的区别也了解的差不多了。点[这里](https://segmentfault.com/q/1010000003872849?_ea=403075)。

URI 是统一资源标识符，而 URL 是统一资源定位符。因此，笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。  
二者的区别在于，URI表示请求服务器的路径，定义这么一个资源。而URL同时说明要如何访问这个资源（http://）。 

今天so tired！这里非常欢迎有大神以及小白来找我讨论，如果我哪里有写错的话也非常愿意听你来给我指导，表示一直缺一个小伙伴一起进步呢，我的微信是Yhspehy。快来找我玩哈！

