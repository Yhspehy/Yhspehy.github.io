---
layout: post
title: 学习心得
tag: 技术
keywords: Study
---

从今天开始，把每天的学习的一些知识小结一下~

### 2017-7-13

windows下全局安装mocha的时候发现无法安装，主要是没有管理员权限，解决方法是以管理员权限运行cmd，再进行全局安装。

设置node.js的全局安装路径：打开git，输入`npm config ls`，修改prefix的值，`npm config set prefix "xxxxxxxx"`就ok了。

关于istanbul这个代码覆盖率工具，如果是在window上和mocha一起使用的时候，要注意不能直接打`istanbul cover _mocha`这个代码，因为window的路径问题，要使用`istanbul cover node_modules/mocha/bin/_mocha`,这个在官方说明上usage on windows也有提到。

学习了一些makefile文件的配置，不过因为在window系统上，所以刚开始使用的时候还是很懵比，怎么也用不了make。后来在`http://sourceforge.net/projects/mingw/files/latest/download?source=files`上下载了GNU编译器，然后在后面的界面中选择基础配置和C++编译器，将MinGW安装目录下的bin中的mingw32-make.exe重命名为make.exe。接着就可以使用make指令了，网上有说要配置系统变量，不过我没配置好像也可以运行。之后我在git上尝试使用make，但是始终告诉我make commend not found，配置了用户变量也是提醒这个错误，我也不知道这个是什么原因0.0。

### 2017-7-5

今天又遇到给后台传参要传数组的问题，发现还是不好传，所以以后还是直接传json对象比较好。今天还遇到表单提交的时候需要另外提交字段，如果后台用了spring，解决方法是接受的时候增加一个参数来解析文字。

今天在使用vuex的时候发现，如果跳转的使用的是`window.location.href`，那么vuex中store保存的信息都会清空，这是因为`window.location.href`会刷新页面。所以在vue中需要跳转的时候最好是用`this.$router.push()`来进行跳转。

### 2017-7-4

一看发现好久没写心得了，最近也比较忙（其实都是借口，就是懒），今天电话面试了一家公司，感觉自己还不错，虽然有些问题没答上来，以及在厕所不敢大声说话。这次面试也学到了蛮多东西，主要是一些js基本的应用概念，太久没写原生js了，发现自己有点忘了，还是要常常温故，之前拉下的js高级教程的笔记也要开始补起来了。今天被问到一些ie8兼容性，MVVM,MVP,MVC框架的区别等等，以前都记过但是忘了，今天重新记下笔记：
1. ie8关于json的兼容性，因为ie8不兼容JSON.parse()的解析方法，所以可以使用eval()方式，不过比较危险，因为eval()在解析的时候会执行字符串中的代码。关于转成字符串，一个比较有趣的方式是将JSON.js改名为JSON2.js，然后调用JSON2.stringify()。
2. MVC框架是最早提出的，用户操作->View（负责接收用户的输入操作）->Controller（业务逻辑处理）->Model（数据持久化）->View（将结果反馈给View）。MVP是把MVC中的Controller换成了Presenter（呈现），目的就是为了完全切断View跟Model之间的联系，由Presenter充当桥梁，做到View-Model之间通信的完全隔离。如果说MVP是对MVC的进一步改进，那么MVVM则是思想的完全变革。它是将“数据模型数据双向绑定”的思想作为核心，因此在View和Model之间没有联系，通过ViewModel进行交互，而且Model和ViewModel之间的交互是双向的，因此视图的数据的变化会同时修改数据源，而数据源数据的变化也会立即反应到View上。  
通过这一段话可以看出MVVM框架比较重要的进步是关于数据的控制，双重绑定保证了数据的一致性，而且在获取数据上也比通过dom操作简单很多。
3. 关于vue的数据渲染逻辑：自定义Render函数，template写法，el写法。不过基本都是用template。
4. Vue中v-bind和v-on的区别，v-bind绑定的是变量，v-on绑定的是方法，虽然知道怎么用但是一时间却说不上来这个。


现在总结一下这半个月学到的一些东西：  
1. 深层次的了解了js中的运算机制，比如`++[[]][+[]]+[+[]] = 10`，`(1+{})[4]= j`等等（详见justjavac博客）
2. 公司新项目的开发，其中用到了一个集合input和select功能的div，就是能用够像select一样进行下拉列表展示，也可以在select框中手动输入数据，并自动filter，主要的思路就是使用一个div，下面包裹一个ul列表用来展示下拉列表。
3. 学习了es6的编码规范
4. 在使用JQuery的时候，注意使用变量的时候使用单引号将字符串隔开

昨天在听了部分justjavac的知乎live中的前端工程师的入门与进阶，我总结几个要点：
1. 前端工程师也还是程序员，所以必须要写出比较好的代码，好的代码包括，代码的很强壮，比较容易维护，逻辑条理清晰
2. 在学习新的框架的时候也不能忘了js，css等基本的东西，很多人都是学习了3个月的知识，然后重复使用了好多年，即使有多年经验，但是知识还是那么多

等有空我单独写一篇心得0.0




### 2017-6-20

毕业典礼请假了半个多月，感慨很多，今天回来上班，那就好好工作学习。那么今天呢，主要学习了关于前端反向代理跨域来调用后端的接口，从而获得数据。

一开始我使用的是ngnix，在配置ngnix的时候我也遇到了一些问题：
1. 当修改了配置文件的时候，ngnix -reload不管用，需要先ngnix -quit，在start ngnix。
2. ngnix监听的端口不能与项目的端口一样，会产生冲突。我一开始使用的是vue的的8080端口，而ngnix的端口是80，所以一直显示404。
3. ngnix的location有两种写法，一种是rewrite，一种是直接在标记的代码结构前添加请求的网址。相比较后一种直接添加的比较方便。

因为使用了vue，如果在项目外重新开ngnix的话，ngnix就监听不了vue的项目了，后来发现vue-cli本来就有反向代理这个功能，就是在config中的index.js，proxyTable这个字段，适用方法如下：
```javascript
proxyTable: {
  'api': {
    target: 'your url',
    changeOrigin: true
  } 
}
```
当你在页面中调用api/aa的时候，返回的数据就是your url/api/aa接口的数据。

当然proxyTable也有rewrite的功能。
```javascript
proxyTable: {
  'api': {
    target: 'your url',
    changeOrigin: true,
    pathRewrite: {
      '^/api': 'bb'
    }
  } 
}
```

这样你在页面中调用api/aa的时候，返回的数据就是your url/bb/aa接口的数据。

### 2017-5-25

在知乎上看到一个话题，有个公司面试了一个5年经验的前端，结果那个面试者答不上原型链的基础知识，张口闭口就是vue，react等框架的实现原理等等，看着评论，大家的反应都不太一样，很多人说面试官要会发现面试者的优点，但是也有很多一批人说连js基础的知识了解的都一知半解，说句实话，感觉如今人们被工具支配的太恐怖了，以至于有了工具却不去了解基础知识了。我在平时的学习中一定要打好基础，努力加油。下面是哪个面试官出的一道题目：

输入m,n，生成一个长度为m的每个数都为n的数组，如果不能用循环，可以使用递归：
```
function t3(m, n) {
  var arr = arguments[2] || []
  if (m > 0) {
    arr.push(n)
    t3(--m, n, arr)
  }
  return arr
}
```
或者使用`new Array(m+1).join('n')`，不过递归的方法没有循环来的性能高。

arguments对象存储的是实际传递给函数的参数，而不局限于函数声明所定义的参数列表，而且不能显式创建 arguments对象。

### 2017-5-11

今天在用vue获取ajax请求的数据的时候发现一个问题，当我在created发出ajax请求来获取数据，在template中调用的时候，会报错，原因是因为当我调用的时候，数据还没有请求到，所以会出现undefined的现象，解决方法是在请假数据的外面包一个div，`v-if="数据"`，这样当数据不存在的时候便不会执行下面的代码，当数据请求到了，会自动更新。

### 2017-5-10

如果要给后台传json字符串的话，比如ajax中的请求是`data: Data`，Data是json字符串，那么需要在ajax中添加这句话，`contentType: 'application/json; charset=utf-8'`，告诉服务器，我给你的json字符串，不然可能会出错。但是如果json字符串是写在data的对象里的话，则不需要写那句话，如：`data: {jsonString: Data}`。

### 2017-4-26

try-catch语句中如果后面跟着finally子句，那么无论try还是catch语句中的return语句都被毁忽略。finally语句一定会被执行。



### 2017-4-21

因为vue中的 &#123;&#123;&#125;&#125; 是文本插值，所以data中的'\n'是不会再html中换行的，不过可以在换行的地方使用`<br>`进行换行，用jq的html()显示


### 2017-4-19

当使用bootstrap的时候，如果子元素设置了margin-top，父元素没有clearfix的话，可能会出现子元素的margin-top应用在了父元素上，即父元素有了margin-top，而子元素还是和父元素紧紧的依靠在一起，解决方法是给父元素clearfix，出现这个的原因是bootstrap中有自带的默认float属性。

### 2017-4-17

在vue中使用datetimepicker插件的时候，因为这个插件是依赖jq的，所以在使用这个插件的时候在先引入Jq，第一种方法在index.html中引入jquery.js，在webpack中加入全局变量$
```javascript
externals: {
    jquery: 'window.$'
  }
```
,然后再index.html中引入插件的js文件，在vue组件中require jq，`var $ = require('jquery')`,就可以使用了。  
第二种方法是在index.html中引入jq文件，然后再vue组件中import插件的js，再require jq，`var $ = require('jquery')`，就ok了


### 2017-4-10

当使用CSS3的nth-child()的时候，千万要记住body是html的第二个子元素，所以nth-child(2)会应用在body上。

CSS的样式优先级：
内联样式 > 内部样式 > 外部样式。  
1. JQ的addClass是在外部文件或者内部样式中定义好的。
2. JQ的.css()是直接通过元素的style属性附加到元素上，属于内联样式。

所以.css()的优先级会高于addClass，当你使用JQ实现点击、hover样式转变的时候，最好使用addClass不容易出错。

### 2017-4-6

word-wrap和word-break的区别：word-wrap是用来决定单词内要不要断句，word-break是用来决定怎么样断句。共同点就是当一个单词过长超过包裹的父级元素的宽度的时候，会另起一行，将单词断开。但是不同点是，word-wrap会先另起一行，即将那个很长的单词另起一行显示，当那个单词太长一行都放不下的时候，再断开。但是word-break不会另起一行显示那个单词，而是接着前面的单词，当那行剩余的部分包裹不了的时候再换行。所以word-break比较节省空间。


### 2017-3-25

页面使用border创建一条线，怎么让它在div中竖直方向居中，除了用了position,，可以使用margin


### 2017-3-23

这几天学习了vue.js

在methods中调用ajax的时候，一开始的this指向vue实例，但是success中的this指向success这个方法，如果要在success方法中调用vue实例中的数据，可以在ajax开头`var self = this`，那这个self就是vue实例。


### 2017-3-17

position:fixed始终以body为父级元素，所以当height为100%的时候就会覆盖整个页面，用来整页修改css很有用。

### 2017-3-15

今天遇到了一个问题，在写项目的时候发现动态生成的48个表单中，有一个表单的样式不对，然后今天自己就好好使用断点来查找问题，最后发现是传回来的数据的末尾是/，然后和&gt;形成了闭合，所以产生了两个tr。所以以后再使用js动态添加节点的时候，最好值和&gt;之间空一个空格，就可以避免这个问题，然后，虽然这个问题很小，但是我比较算正式的使用了断点这个功能，感受了他的魅力！


### 2017-3-13

今天遇到一个错误，显示Uncaught SyntaxError: Unexpected token o in JSON at position 1  
查了一下资料，原因是接收到的json已经是对象了，所以不能再使用JSON.parse()将之转换成对象。  


### 2017-3-10

项目基本写完了，这几天都在看JavaScript高级程序设计，看了BOM,DOM,客户端检测，感觉看的晕乎乎的，没有前面几章看到有兴趣，也许是因为这几张比较侧重实例，不过自己还是要好好啃完它，啃完就要准备开始学习vue了。


### 2017-3-8

昨天和今天主要在为原来的项目增加可爬的数据类型，其中有好几种很复杂的数据，数列对象各种包，这里写几个遇到的一些麻烦。

1. input end不规范基本是因为{}没有断好。  
2. 不要使用if，if，else。应该使用if，else if，else。  
3. 注意input和textarea。  
4. 如果对象的属性是变量的时候，需要使用obj[]来获取属性，必要的时候自己来构建一个str。比如：str="[parma"+1+"]",obj[str]。这里的str=[parma1]。
5. 在写ajax的时候，如果data是一个json对象，可以在赋值的时候直接添加到data里，也可以全部赋值完后统一定义data。
6. 使用JQ通过变量来获取某个节点的值的时候，不能直接$(name div)，应该使用find，parent等方法来获取。
7. 注意使用return false的后果。如果在循环中使用return false会直接种植循环。其次，return语句只能在函数中使用，起的地方使用会报Illegal return statement错误。
8. 使用Object.getOwnPropertyNames(a).length可以获取对象，数组的长度。

### 2017-3-6

写完项目的所有接口，用了很多数组的方法，也在js写了很多动态创建html的代码，从刚开始的不会使用++到现在的比较熟练，感觉还是学到了很多。


### 2017-3-4

今天写了分页，动态的获取数据库里的信息，发现一开始自己写的太复杂，其实写起来很简单，也学到了怎么通过this获取this里面的span的内容。
```javascript
$('>span',this).text()
```




### 2017-3-2

今天遇见输入input时只要点击空格键就会自动提交并刷新表单，解决方法是：
```javascript
$("input").keydown(function(event){
     if(event.keyCode==13)return false;
    })
```

这里的keyCode==13是代表回车键。

使用了confirm()，在confirm()中二次使用ajax。

优化了项目中获取数据的表达式，感觉以后自己再写代码的时候要多注意代码的质量，考虑到可维护性，以及算法的优化。




### 2017-3-1

split(),join()用来数组和字符串的转换

学习了BOM，window对象，了解了window.location对象，并使用了其中的href和search的用在了自己的项目里。  
使用了window.open(),window.location.href等等。





### 2017-2-28

JQ: focus()方法相当于Javascript中的onfoucs()方法，作用是处理获得焦点的事件。    
    blue()方法相当于Javascript中的onblur()方法，作用是处理失去焦点的事件。    
    offset()方法是获取元素在当前视窗的相对偏移。  
    scrollTop()和scrollLeft()方法是获取元素的滚动条距顶端的距离和距左侧的距离。这两个方法也可以指定一个参数，控制元素的滚动条滚到到指定位置。





### 2017-2-27

JQ的选择器，了解了选择和筛选的区别，children()是筛选子元素的，不会考虑其他后代元素，空格是选择后代的，&lt是选择子元素的。

next()用于取得匹配元素后面紧邻的同辈元素。  
prev()用于取得匹配元素前面紧邻的同辈元素。  
siblings()用于取得匹配元素前后的所有同辈元素。(ps：这个函数很有用，可以用来点击按钮的时候改变class)  
closest()方法用于取得最近的匹配元素。

```javascript
$("#CrawlerTable").delegate(".c-start","click",function(){
    var startId=$(this).parents("tr").attr("id");
    $.ajax({
      type: "POST",
      xhrFields: {
          withCredentials: true
      },
      crossDomain: true,
      url:dataUrl+"/SpyderPlatform/spyderInfo/start",
      dataType: "json",
      data:{
        id:startId
      },
      success:function(data){
        if(data.result == true){
          alert("启动成功");
          window.location.reload
        }else{
          alert("启动失败或者已经启动");
        }
      }
    })
  })
```
这里的xhrFields的是用来设置本地XHR对象的"名-值"映射，可以在需要时设置"withCredentials"为true二人执行跨域名请求。  
而crossDomain为true为跨域请求，false为同域请求。



### 2017-2-23

ajxx的基本格式：

```javascript
$('#mysave').click(function(){
            $.ajax({
                type:"POST",
                url:{},                
                datatype:'json';
                async: false,
                error: function(request) {
                    alert("Connection error");
                },
                success: function(data) {
                    $("#").parent().html(data);
                }
            })
        })
```

这里的data是发送到服务器的数据，如果不是字符串，将自动转换为字符串格式。可以想要防止这种自动转换，可以使用processData选项。  
dataType是预期服务器返回的数据类型，如果不指定，JQuery将自动根据HTTP包MIME信息返回responseXML或responseText,并作为回调函数参数传递。可用的类型有：xml,html,json,script,jsonp,text。


 jQuery 中bind(),live(),delegate(),on()区别,点击[这里](http://blog.csdn.net/hi_kevin/article/details/37757657).

 今天在写项目的时候由于需要动态的创建文本，而文本里面有一些按钮来控制动态效果，如果只用click，bind事件来绑定这几个按钮的话，会发现浏览器没有报错也没有执行，查了资料请教了主管后才之后这个时候需要使用deligate()方法，deligate()方法可以绑定未来的元素，比如脚本新创建的一些元素，而live()和deligate()的原理相同，只是live()是绑定到元素上，而deligate()可以通关过父级元素绑定到子元素。live()方法已经在JQ1.7版本被弃用，所以最后不要再使用，而以上的方法都是通过on()方法来实现，所以on()是万能的。


### 2017-2-22

margin-top,margin-left,margin-right,margin-bottom 是body中的属性  
th,td 是表格的元素,与之对应的是  
padding-top,padding-left,padding-right,padding-bottom,以及 vspace,hspace,cellspacing,cellPadding=0
等元素

今天学习了input框的一些属性：placeholder，required等，还有一个label的for，配合input的id使用。

JQ的clone()，index()，attr()，find()，after().

clone()可以解决一些需要动态创建相同格式的html元素。

index()这个函数也很有用，比如当我们点击一个按钮的时候，如果这类按钮有很多个，但是我们需要知道这个按钮的index，比如点一个按钮，然后会使包裹他的父级div消失，因为都是同时出现的，只有合理的设置好class，这个时候我们就可以通过按钮的index来得到div的index，从而操控，但是如果我们要自己写，思路就是点击这个按钮的时候，最关键的就是得到这个按钮的index，但是如果我们用普通的js来写就会有点麻烦，因为要得到按钮的index，你首先需要遍历所有的这类按钮，然后给每个按钮一个index，比如btn.index = i ; 然后再次循环给每个按钮一个click事件，但是如果第二次循环给按钮一个click事件，那当我们点击这个按钮的时候就不会触发这个click函数，所以这时候我们就需要index()这个函数来写。

就可以通过index()解决。  
```javascript
	$(document).ready(function(){ 
	$(".Element").click(function(){        //添加按钮元素
	   alert($(.Element).index($(this)[0]));
	   })
	}) 
```


### 2017-2-18

这几天学了一点vue.js，推荐一个比较轻松愉快的入门博客，点[这里](http://www.cnblogs.com/keepfool/p/5619070.html).

### 2017-2-15

轻松愉快的一天！一天都在面试，所以晚上放松一天，明天继续努力学习！（晚上找了一些之前几个问题的答案，已附上）

oh my god~!

刚才遇到了被占用端口的问题，通过[这个](http://www.cnblogs.com/lxconan/p/who-is-using-my-port.html)才了解

原来也是我的福昕阅读器占用了我的端口~
 
### 2017-2-14

今天是情人节哟，不知道小伙伴们都有没有人陪，我今天又在图书馆呆了一天，今天学习了原型的继承，函数表达式，因为明天的面试，略微的看了xml，json和ajax技术，没有足够的时间让我准备心里还是有点难过的，晚上具体的看了些ajax的代码，希望明天面试顺利，加油！



### 2017-2-13

今天在图书馆泡了一天，收获的不是一般的多，看了很多js的书，大概写了以下一些问题。

1. 正则表达式的概念
2. 创建数组时用new和不用的区别
3. new操作符在js中的意义
4. 如何提升js的性能
5. 函数声明，函数表达式的区别，以及一些扩展（声明提前，变量提前）
6. URL和URI的区别

好了，现在来一个个的解决。

正则表达式的含义我用一张图来解释。

<p><img src="/public/tech/Study/regex.png"></p>

关于创建数组时用不用new需要知道两个概念，就是栈对象和堆对象，在JS高程里面的第119页详细的介绍了，如果用new来创建一个新数组的，那这个数组就是属于堆对象，他不会自动销毁，需要手动释放否则可能会出现内存泄露。如果不用new的话，那这就是一个栈对象，这个只存在一行代码的执行瞬间，然后立即被销毁。

new操作符在js中的意思，当用new操作符创建一个空对象时，this指向该空对象，而且这个对象会继承原函数的原型，属性和方法也会加入到this引用的对象中。新创建的对象由this引用，并且最后隐式的返回this。

如何提升js问题，我发现一个比较不错的博客，推荐给大家，点[这里](http://www.chinaz.com/web/2015/0626/417391.shtml)。

函数声明，函数表达式的区别其实很简单，就是函数声明的话函数名和函数体会提前，他属于那种随叫随到的，只要你需要了，我就到了。而函数表达式不会提前，他是属于那种只有你到我这里了，你才能见到我，不然休想。再翻其他资料的时候，也看了很多关于变量提前，以及关于这三者混合出现的一些情况。  
这里简单的说下当变量声明和函数声明同时提升的时候（变量名和函数变量名相同），函数声明会覆盖变量声明，即最终那个变量显示的结果以函数为准，这个是变量声明而不是变量赋值。其中这个有一道比较好的题目，如果理解了这个应该对这几个名词的区别也了解的差不多了。点[这里](https://segmentfault.com/q/1010000003872849?_ea=403075)。

URI 是统一资源标识符，而 URL 是统一资源定位符。因此，笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。  
二者的区别在于，URI表示请求服务器的路径，定义这么一个资源。而URL同时说明要如何访问这个资源（http://）。 

今天so tired！这里非常欢迎有大神以及小白来找我讨论，如果我哪里有写错的话也非常愿意听你来给我指导，表示一直缺一个小伙伴一起进步呢，我的微信是Yhspehy。快来找我玩哈！

