---
layout: post
title: http相关知识总结
tag: 技术
keywords: http
---

今天来总结一下http相关知识。

http(HyperText Transfer Protocol)：超文本传输协议，是互联网上应用最为广泛的一种网络协议，建立在TCP协议上。用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。默认端口为80.

https(Hyper Text Transfer Protocol over Secure Socket Layer)：在http的基础上，加入了SSL来加密传输内容。在后来的发展中，SSL逐渐演变成TLS。默认端口未443。

spdy：是Google开发的既有TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。PDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。新协议的功能包括数据流的多路复用、请求优先级以及HTTP报头压缩。

http2.0：即超文本传输协议2.0，是下一代的HTTP协议。HTTP2.0可以说是SPDY的升级版。不会改动HTTP 的语义，HTTP 方法、状态码、URI 及首部字段，等等这些核心概念上一如往常，却能致力于突破上一代标准的性能限制，改进传输性能，实现低延迟和高吞吐量。


## http的基本优化

影响一个HTTP网络请求的因素主要有两个：带宽和延迟。但是目前网络建设已经使宽带得到了极大的提升，我们所需要关心的只是延迟了。
1. 浏览器堵塞(HOL blocking)：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。
2. DNS查询：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。可以使用`dns-prefetch`来进行预处理。
3. 建立连接：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。



## HTTP1.0和HTTP1.1的一些区别

1. 缓存处理，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
2. 带宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
3. 错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
4. Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。
5. 长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。



## HTTP1.0和1.1现存的一些问题

1. 上面提到过的，HTTP1.x在传输数据时，每次都需要重新建立连接，无疑增加了大量的延迟时间，特别是在移动端更为突出。
2. HTTP1.x在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性。
3. HTTP1.x在使用时，header里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求header基本不怎么变化，尤其在移动端增加用户流量。
4. 虽然HTTP1.x支持了keep-alive，来弥补多次创建连接产生的延迟，但是keep-alive使用多了同样会给服务端带来大量的性能压力，并且对于单个文件被不断请求的服务(例如图片存放网站)，keep-alive可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。



## HTTPS与HTTP的一些区别
1. HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。
2. HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。
3. HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4. HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。


## HTTPS改造

1. 安装CA证书，一般的证书都是需要收费的，这边推荐一个比较好的购买证书网站：1）Let's Encrypt，免费，快捷，支持多域名（不是通配符），三条命令即时签署+导出证书。缺点是暂时只有三个月有效期，到期需续签。2Comodo PositiveSSL，收费，但是比较稳定。
2. 在购买证书之后，在证书提供的网站上配置自己的域名，将证书下载下来之后，配置自己的web服务器，同时进行代码改造。
3. HTTPS 降低用户访问速度。SSL握手，HTTPS 对速度会有一定程度的降低，但是只要经过合理优化和部署，HTTPS 对速度的影响完全可以接受。在很多场景下，HTTPS 速度完全不逊于 HTTP，如果使用 SPDY，HTTPS 的速度甚至还要比 HTTP 快。
4. 相对于HTTPS降低访问速度，其实更需要关心的是服务器端的CPU压力，HTTPS中大量的密钥算法计算，会消耗大量的CPU资源，只有足够的优化，HTTPS 的机器成本才不会明显增加。


## 使用SPDY加快你的网站速度

1. 降低延迟，针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。
2. 请求优先级（request prioritization）。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。
3. header压缩。前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。
4. 基于HTTPS的加密协议传输，大大提高了传输数据的可靠性。
5. 服务端推送（server push），采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。


## http2.0和SPDY的区别

1. HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS。
2. HTTP2.0 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE。



## http2.0的新特性

1. HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
2. 多路复用请求：即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。
3. 对请求划分优先级：可以优先处理优先级高的请求。
4. 压缩header：用encode压缩header大小，并且去除了header大量重复的信息，而通讯双方各自缓存一份基础首部表。每次有新增或者修改的首部帧就会被追加到首部帧中。如果请求中不包含首部，那么就自动使用首部表的内容。
5. 服务器推送：同SPDY一样，HTTP2.0也具有server push功能。

## HTTP2.0的升级改造

1. 前文说了HTTP2.0其实可以支持非HTTPS的，但是现在主流的浏览器像chrome，firefox表示还是只支持基于 TLS 部署的HTTP2.0协议，所以要想升级成HTTP2.0还是先升级HTTPS为好。
2. 当你的网站已经升级HTTPS之后，那么升级HTTP2.0就简单很多，如果你使用NGINX，只要在配置文件中启动相应的协议就可以了，可以参考NGINX白皮书，NGINX配置HTTP2.0官方指南。
3. 使用了HTTP2.0那么，原本的HTTP1.x怎么办，这个问题其实不用担心，HTTP2.0完全兼容HTTP1.x的语义，对于不支持HTTP2.0的浏览器，NGINX会自动向下兼容的。


## SSL和TSL的区别

SSL和TLS都是加密协议，可在通过网络运行的服务器，机器和应用程序（例如，连接到Web服务器的客户端）之间提供身份验证和数据加密。 SSL是TLS的前身。 多年来，新版本的协议已经发布，以解决漏洞，并支持更强大，更安全的密码套件和算法。  
SSL最初是由Netscape开发的，最初于1995年以SSL 2.0（1.0从未向公众发布）登场。 在发现一些漏洞后，版本2.0在1996年很快被SSL 3.0所取代。  
TLS于1999年作为SSL的新版本推出，并基于SSL 3.0：这个协议和SSL 3.0之间的差异并不明显，但它们足够重要，TLS 1.0和SSL 3.0不会互相影响。  
SSL和TLS是否有加密方式的不同？事实上讲，这个问题的答案是肯定的。是您可以对SSL 2和3的历史版本和TLS的1.1,1.2或1.3版本进行相同的说明。 SSL和TLS都基于相同的协议，但由于版本的不同，SSL 2与版本3不兼容，而SSL版本3与TLS版本1不兼容。但是你可以认为TLS只是SSL 4的别名，他们都是同一个协议。


## HTTP中的状态码(301，302，303，307， 304)

301永久性转移，302暂时性转移。

301，302是http1.0的内容，303、307是http1.1的内容。

301和302本来在规范中是不允许重定向时改变请求方法的（将POST改为GET），但是许多浏览器却允许重定向时改变请求方法（这是一种不规范的实现）。因为post方法不是幂等，所以post操作会不符合用户预期，所以必须跟用户确认要重发后，才能进行第二次post请求，而不是get请求。

303就是将301、302状态码的处理动作”合法化”了，也就是允许重定向时改变请求方法。此外303响应禁止被缓存。大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的，所以303基本用的很少，一般用302。

307状态码就是要求301，302遵守规定，出了get和head方法外，其他请求方法必须等到客户端确认后才能跳转，并且请求方式不会改变。

307还应用于hsts跳转。  
hsts全称HTTP严格传输安全（HTTP Strict Transport Security，縮寫：HSTS），功能是要求浏览器下次访问该站点时使用https来访问，而不再需要先是http再转https。这样可以避免ssl剥离攻击，即攻击者在用户使用http访问的过程中进行攻击，对服务器冒充自己是用户，在攻击者和服务器中使用https访问，在用户和服务器中使用http访问。

具体使用方法是在服务器响应头中添加 Strict-Transport-Security，可以设置 max-age

304：协商缓存。  
浏览器缓存分为强制缓存和协商缓存，优先读取强制缓存。  
强制缓存分为expires和cache-control，而expires是一个特定的时间，是比较旧的标准和cache-control通常是一个具体的时间长度，比较新，优先级也比较高。  
而协商缓存包括etag和last-modified，last-modified的设置标准是资源的上次修改时间，而etag是为了应对资源修改时间可能很频繁的情况出现的，是基于资源的内容计算出来的值，因此优先级也较高。  
协商缓存与强制缓存的区别在于强制缓存不需要访问服务器，返回结果是200，协商缓存需要访问服务器，如果命中缓存的话，返回结果是304。






## 结尾

> ### 相关链接：
> * HTTP,HTTP2.0,SPDY,HTTPS你应该知道的一些事[这里](http://www.alloyteam.com/2016/07/httphttp2-0spdyhttps-reading-this-is-enough/)
> * HTTP2.0的奇妙日常[这里](http://www.alloyteam.com/2015/03/http2-0-di-qi-miao-ri-chang)
> * SSL vs. TLS - What's the Difference?[这里](https://www.globalsign.com/en/blog/ssl-vs-tls-difference/)
