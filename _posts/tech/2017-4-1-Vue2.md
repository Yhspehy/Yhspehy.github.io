---
layout: post
title: Vue2.js学习
tag: 技术
keywords: Vue.js
---

## Vue2.js

### 父子组件的值的传输

这是父组件的代码

```html
<template>
  <div class="hello">
    <input type="text" v-model="me">
    <say :me='me' v-on:we="www"></say>  	<!-- :me是给子组件传值，v-on是取子组件的值，使用的是监听子组件的事件,v-on不能使用缩写@，这里的v-on其实是vm.$on,这是实例方法，而template中的v-on是一个指令,注意这里的www不能和后面的wwww重名，而me可以和v-model的me重名，因为v-model的me是父组件的，而传给子组件的me是子组件的，而www都是父组件的 -->
    <div>{{wwww}}</div>
  </div>
</template>
```

```javascript
import say from '@/components/say'   //引入子组件

export default {
  name: 'hello',
  data () {
    return {
      me: '',
      wwww: ''
    }
  },
  components: { say },			//注册子组件
  methods: {					//从子组件拿值，别忘了(val)，这是子组件的值
    www: function (val) {
      this.wwww = val
    }
  }
}
```


这是子组件的代码

```html
<template>
	<div>
	  <div>{{me}}</div>
		<input type="text" v-model="we"/>
	</div>
</template>
```

```javascript
export default {
  props: ['me'],    //从父组件拿值
  data () {
    return {
      we: ''
    }
  },
  watch: {             //监听input的值的变化，一有变化就将值传给父组件，传值中别忘了this.we，这是将值连同事件一起传给父组件
    we: function (val, oldval) {
      this.$emit('we', this.we)      
    }
  }
}
```

emit是在子组件中定义的，父组件使用v-on来监听子组件emit的事件。

v如果需要动态的传递数据，最好不要用refs，因为它并不是响应的，引用官方文档的话：$refs只在组件渲染完成后才填充，并且它是非响应式的。它仅仅作为一个直接访问子组件的应急方案——应当避免在模版或计算属性中使用 $refs 。

### data

基本上在template中出现的所有v-show,v-if,v-model,v-bind,v-on等指令中的变量都需要在data中定义，建议一类一类定义，不要直接定义在return这个大类中，推荐一个vue插件：Vue.js devtools。这个插件可以实时的查看vue项目中所有的值，组件。









### vue-route

使用vue的时候页面的url的相关信息可以通过$route来获取，具体的请点[这里](https://router.vuejs.org/zh-cn/api/route-object.html)

最近写的一些项目发现打包后跳转页面出现问题，直接跳转到了磁盘目录，比如如果项目放在c盘，就会直接跳转到了c盘，查看了一下跳转目录的写法，发现当时写的是/#/tasks/name这类的，结果跳转的时候就会少了index.html，但是在原来的项目中是不会出现这样的情况的。



### vuex

最近稍微用了一下vuex，刚开始自己用的也是很迷糊，在这里将一些疑惑记录下来。

但是不得不说，vuex可以减少很多数据交互的步骤，特别是同胞组件的数据交互。

在定义store完，千万不要忘记在根组件中输出。

```javascript
import Vuex from 'vuex'
import Vue from 'vue'

Vue.use(Vuex)

const store = new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    add: state => state.count++,
    del: function (state) {
      state.count = state.count - 1
    }
  },
  actions: {
    add ({commit}) {
      commit('add')
      commit('del')
    }
  }
})

export default {
  store,      // 千万不要忘了输出，不然子组件中没有store
  name: 'hello'
}
```

最好用action来进行操作，将操作变化的数据传给指定的mutations，然后让mutations来改变数据。因为mutations必须同步执行，而action不受约束，我们可以在action内部执行异步操作。

因为之前箭头函数用的不多，今天学习了一下，我感觉箭头函数适用于那些直接return的函数，对于这种需要对值进行操作的还是用普通的函数好用，因为我用`state => state.count - 1`的时候值并不会减1。而且要注意箭头函数的this的指向。

当你使用模块的时候，要注意每个模块的actions和mutitaions都是在全局变量里的，state是分模块的。所以如果要在子组件使用actions的时候，最好在模块定义actions的时候规划好命名，不要命名冲突，可以使用前缀后者后缀。当你要获取vuex中模块的state的时候，要在`this.$store.state.模块名称.key`，比如模块名称是a，你要获取a中的count，那么你就要写`this.$store.state.a.count`。

当使用vuex应用在表单中的时候，如果应用在v-model上时，要注意的一点是，因为要使用computed属性，所以不要在data中定义计算属性的变量。  
如：  
```html
<input type="text" v-model="ww">
```
```javascript
data () {
  return {
    ww: ''    //注意这里不能写ww：''，不能再data里面注册
  }
},
computed: {
  ww () {
    return xxxxx    //因为计算属性中已经定义了ww，所以不能在data里面定义，不然就会冲突，data里面的ww会覆盖computed里面的ww，不管ww怎么变，页面只显示data里面ww的值
  }
}
```





### 别的小问题

#### 怎么再router-link上绑定click事件

`@click.native=""`在click后面加上`.native`就好