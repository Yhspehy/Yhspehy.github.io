---
layout: post
title: Vue3源码
tag: 技术
keywords: Vue3
---

## 起源

本次我看 Vue3 源码的初衷是因为，在目前 Vue3 的设计中，给子组件绑定原生事件的时候，比如 onClick，在父组件 re-render 的时候，子组件上的 onClick 也会重新生成，这就会导致子组件的 re-render。特别是在使用 v-for 的时候，那这个子组件更新的频率就很高了，如果要优化的话有点像 react 的 useCallback 了。虽然 Vue3 也提供了 v-memo 让我们手动去设置依赖（使用 memo 的时候甚至会略过 VNode 的生成），但是如果这原本就可以从底层去实现的话，岂不是更好。所以我就开始基于这个问题去构思一下是从可以给 Vue3 提个 pr。

不过既然准备开始看 Vue3 源码，那也还是记录一下，常看常新。

## 入口

runtime-dom/index.ts 暴露出 createApp Api,其中需要通过 createRenderer 生成 baseRenderer，其中 baseRenderer 中包含了 patch 等各种底层 api。而 baseRenderer 导出项为：

```js
return {
  render,
  hydrate,
  createApp: createAppAPI(render, hydrate),
};
```

导出的 createApp 函数中，会返回 app 对象，其中有熟知的 mount，unmount，component，mixin，directive，use 等 api。

在执行 mount 的时候，会基于 rootComponent，通过 createVNode 来生成 rootVNode，这里的 node 是包含第一层的，并不会直接遍历子节点。

```js
if (isHydrate && hydrate) {
  // 主要用于ssr，用来复用原本已经存在的DOM 节点，减少重新生成节点以及删除原本DOM 节点的开销，来加速初次渲染的功能，应该是这样
  hydrate(vnode as VNode<Node, Element>, rootContainer as any)
} else {
  // 我们客户端使用的时候就会调用这个
  // 在这里就会变遍历子节点同时render
  render(vnode, rootContainer, isSVG)
}
```

而这里的 render 函数，就是 baseRenderer 中导出的 render。

```js
const render: RootRenderFunction = (vnode, container, isSVG) => {
  if (vnode == null) {
    if (container._vnode) {
      unmount(container._vnode, null, null, true);
    }
  } else {
    // 因为首次render的时候是没有_vnode的，所以会直接去生成节点
    patch(container._vnode || null, vnode, container, null, null, null, isSVG);
  }
  flushPreFlushCbs();
  flushPostFlushCbs();
  container._vnode = vnode;
};
```

既然我们主要去看组件的 patch，那就直接看 processComponent 的实现。

```js
  // renderer.ts
  const processComponent = (
    n1: VNode | null,
    n2: VNode,
    container: RendererElement,
    anchor: RendererNode | null,
    parentComponent: ComponentInternalInstance | null,
    parentSuspense: SuspenseBoundary | null,
    isSVG: boolean,
    slotScopeIds: string[] | null,
    optimized: boolean
  ) => {
    n2.slotScopeIds = slotScopeIds
    if (n1 == null) {
      if (n2.shapeFlag & ShapeFlags.COMPONENT_KEPT_ALIVE) {
        ;(parentComponent!.ctx as KeepAliveContext).activate(
          n2,
          container,
          anchor,
          isSVG,
          optimized
        )
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          optimized
        )
      }
    } else {
      updateComponent(n1, n2, optimized)
    }
  }

  // renderer.ts
  const updateComponent = (n1: VNode, n2: VNode, optimized: boolean) => {
    const instance = (n2.component = n1.component)!
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (
        __FEATURE_SUSPENSE__ &&
        instance.asyncDep &&
        !instance.asyncResolved
      ) {
        // async & still pending - just update props and slots
        // since the component's reactive effect for render isn't set-up yet
        if (__DEV__) {
          pushWarningContext(n2)
        }
        updateComponentPreRender(instance, n2, optimized)
        if (__DEV__) {
          popWarningContext()
        }
        return
      } else {
        // normal update
        instance.next = n2
        // in case the child component is also queued, remove it to avoid
        // double updating the same child component in the same flush.
        invalidateJob(instance.update)
        // instance.update is the reactive effect.
        instance.update()
      }
    } else {
      // no update needed. just copy over properties
      n2.el = n1.el
      instance.vnode = n2
    }
  }

  // componentRenderUtils.ts
  export function shouldUpdateComponent(
    prevVNode: VNode,
    nextVNode: VNode,
    optimized?: boolean
  ): boolean {
    const { props: prevProps, children: prevChildren, component } = prevVNode
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode
    const emits = component!.emitsOptions

    // Parent component's render function was hot-updated. Since this may have
    // caused the child component's slots content to have changed, we need to
    // force the child to update as well.
    if (__DEV__ && (prevChildren || nextChildren) && isHmrUpdating) {
      return true
    }

    // force child update for runtime directive or transition on component vnode.
    if (nextVNode.dirs || nextVNode.transition) {
      return true
    }

    if (optimized && patchFlag >= 0) {
      if (patchFlag & PatchFlags.DYNAMIC_SLOTS) {
        // slot content that references values that might have changed,
        // e.g. in a v-for
        return true
      }
      if (patchFlag & PatchFlags.FULL_PROPS) {
        if (!prevProps) {
          return !!nextProps
        }
        // presence of this flag indicates props are always non-null
        return hasPropsChanged(prevProps, nextProps!, emits)
      } else if (patchFlag & PatchFlags.PROPS) {
        const dynamicProps = nextVNode.dynamicProps!
        for (let i = 0; i < dynamicProps.length; i++) {
          const key = dynamicProps[i]
          if (
            nextProps![key] !== prevProps![key] &&
            !isEmitListener(emits, key)
          ) {
            return true
          }
        }
      }
    } else {
      ...
    }

    return false
  }

```

这里可以看到，首先我们更新的时候 patchFlag 并不是 DYNAMIC_SLOTS 也不是 FULL_PROPS，其实就是 dynamicProps 上我们绑定的原生事件前后 2 个 VNode 对比不一样了，所以就 update 了。那是不是我们只要把我们自己绑定的原生事件从 dynamicProps 上去掉就可以了呢？如果不是原生事件就依旧保留在 dynamicProps。

那我们就要去查看生成 VNode 函数的地方了，结果发现 dynamicProps 是一个参数，那我们还是根据第一次组件挂载的顺序去看代码吧。

```js
function _createVNode(
  type: VNodeTypes | ClassComponent | typeof NULL_DYNAMIC_COMPONENT,
  props: (Data & VNodeProps) | null = null,
  children: unknown = null,
  patchFlag: number = 0,
  dynamicProps: string[] | null = null,
  isBlockNode = false
): VNode {
  ...
}
```

第一次挂载的时候，将根组件 processComponent，然后会执行 mountComponent，接着在 mountComponent 中执行 setupComponent(instance)来进一步完善组件实例。

```js
export function setupComponent(
  instance: ComponentInternalInstance,
  isSSR = false
) {
  isInSSRComponentSetup = isSSR;

  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);

  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);

  const setupResult = isStateful
    ? setupStatefulComponent(instance, isSSR)
    : undefined;
  isInSSRComponentSetup = false;
  return setupResult;
}
```

这里会去初始化 props 和 slots，然后会根据 setup 是否返回了值来决定是否要执行 setupStatefulComponent，在 setupStatefulComponent，中还会执行 finishComponentSetup。

执行完 setupComponent 后就会去执行 setupRenderEffect。在 setupRenderEffect 中，因为已经拿到了组件的 render 函数，然后就会根据 render 函数去执行 renderComponentRoot 获得 subTree，其中
