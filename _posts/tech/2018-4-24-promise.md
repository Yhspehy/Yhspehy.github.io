---
layout: post
title: 实现es6的promise
tag: 技术
keywords: promise
---

今天学习一下别人实现的promise的代码。

[这是源码](https://github.com/laughing-pic-zhu/yield-promise-Test/blob/master/promise.js)

```js
        var PENDING = 0;
        var FULFILLED = 1;
        var REJECTED = 2;

        /*
        value状态为执行成功事件的入参，deferreds保存着状态改变之后的需要处理的函数以及promise子节点，构造函数里面应该包含这三个属性的初始化
         */

        class Promise {
            constructor(callback) {
                this.status = PENDING;
                this.value = null;
                this.defferd = [];
                this.resolve = this.resolve.bind(this)
                this.reject = this.reject.bind(this)
                callback(this.resolve, this.reject)
            }

            //触发改变promise状态到FULFILLED
            resolve(result) {
                this.status = FULFILLED;
                this.value = result;
                this.done();
            }

            //触发改变promise状态到REJECTED
            reject(error) {
                this.status = REJECTED;
                this.value = error;
                this.done();
            }

            //处理defferd
            handle(fn) {
                if (!fn) {
                    return;
                }
                var value = this.value;
                var t = this.status;
                debugger;
                var p;
                if (t === FULFILLED && typeof fn.onfulfiled == 'function') {
                    p = fn.onfulfiled(value);
                }
                if (t === REJECTED && typeof fn.onrejected == 'function') {
                    p = fn.onrejected(value);
                }
                console.log(this)
                // 如果then中是一个新的Promise对象
                if (p && p.constructor === Promise) {
                    p.defferd = fn.promise.defferd;
                    debugger;
                }
            }

            //触发promise defferd里面需要执行的函数
            done() {
                console.log('done')
                debugger;
                var status = this.status;
                if (status === PENDING) {
                    return;
                }
                var defferd = this.defferd;
                for (var i = 0; i < defferd.length; i++) {
                    this.handle(defferd[i]);
                }
            }

            /*储存then函数里面的事件
            返回promise对象
            defferd函数当前promise对象里面
            */
            then(success, fail) {
                console.log('then')
                var o = {
                    onfulfiled: success,
                    onrejected: fail
                };
                var status = this.status;
                o.promise = new this.constructor(function () {});
                if (status === PENDING) {
                    this.defferd.push(o);
                    debugger;
                } else if (status === FULFILLED || status === REJECTED) {
                    this.handle(o);
                }
                return o.promise;
            }

        }


        let promise1 = new Promise((resolve, reject) => {
            resolve(3);
        }).then((res) => {
            return new Promise((resolve, reject) => {
                setTimeout(() => resolve(res + 1), 1000);
            })
        }).then((res) => {
            console.log(res)
            return new Promise((resolve, reject) => {
                setTimeout(() => resolve(res + 1), 1000);
            })
        }).then((res) => {
            console.log(res)
        })
```

