---
layout: post
title: React.js学习
tag: 技术
keywords: React
---

文章开头总是不知道怎么写，想了 5 分钟也想不出来，那我还是就直接写吧。

React 是我学前端以来一直想学的框架，毕竟 facebook 开发的对吧，高大上。哈哈。虽然一直想学，但是我自己还是想等我自己的基础打的扎实一点再去学习。所以一直拖到了现在。

现在自己每天在有空的时候学习 React 和 node，并打算做一个小小的博客网站。也算是一个操练这 2 个工具的小项目。当然刚开始学，肯定会遇到很多问题，我就把 React 相关的坑或者是自己疏忽的地方记录在这里！

## router 参数获取的方式

因为之前使用的是 Vue，对于 router 可以在组件中直接通过`this.$router`来获得相关数据，但是在 React 中，如果要操控路由，想获得 router 的参数有点麻烦，我一开始是一层一层传递给子组件。但是后来看到了 context，虽然官网一直说不要用少用，但是既然 React Router V4 都是采用这个实现，那我也用这个获取下 router 应该也无碍了。  
在 React Router V4 中因为 router 中会默认设置 childContextTypes 和 getChildContext，所以只要在你任何想要 router 参数的组件中，写下如下代码：

```js
  const PropTypes = require('prop-types');

  class componentName extends React.Component {
    componentDidMount () {
      console.log(this.context.router)   // 即可获取到
    }

    .........
  }

  componentName.contextTypes = {
    router: PropTypes.object
  };

```

## create-react-app 构建项目，配置 css-loader,sass-loader,antd

首先使用 create-react-app 构建相项目，然后`yarn eject`暴露出原本隐藏的配置文件(config 文件中)。

然后配置 css-loader：

```js
          {
            //因为要配置antd，不能将模块中的css模块化，否则会出现无法渲染的情况
            //因为要配置scss，所以要加上scss
            test: /(\.scss|\.css)$/,
            exclude: /node_modules|antd\.css/,
            use: [
              'style-loader',
              {
                loader: 'css-loader',
                options: {
                  importLoaders: 2,
                  modules: true,     // 开启css-loader的modules功能
                  localIdentName: '[name]__[local]__[hash:base64:5]',    // 定义模块后的命名格式
                },
              },
              {
                loader: require.resolve('postcss-loader'),
                options: {
                  // Necessary for external CSS imports to work
                  // https://github.com/facebookincubator/create-react-app/issues/2677
                  ident: 'postcss',
                  plugins: () => [
                    require('postcss-flexbugs-fixes'),
                    autoprefixer({
                      browsers: [
                        '>1%',
                        'last 4 versions',
                        'Firefox ESR',
                        'not ie < 9', // React doesn't support IE8 anyway
                      ],
                      flexbox: 'no-2009',
                    }),
                  ],
                },
              },
              // 这个和关键，让modules功能能识别scss的文件
              'sass-loader',
            ],
          },
          {
            // 配置antd的css-loader
            test: /(\.scss|\.css)$/,
            include: /node_modules|antd\.css/,
            use: [
              require.resolve('style-loader'),
              {
                loader: require.resolve('css-loader'),
                options: {
                  importLoaders: 1,
                },
              },
            ],
          },
```

接着配置 antd：

官网上给出的方法是在使用 create-react-app 后使用`react-app-rewire-less` 插件来给配置文件添加内容，但是当我们暴露配置文件后就不需要这么操作了，我们可以直接将内容添加进去。

```js
      {
        test: /\.(js|jsx|mjs)$/,
        enforce: 'pre',
        use: [
          {
            // 添加antd的相关配置，注意这里要写在eslint-loader之前，否则会报错
            loader: require.resolve('babel-loader'),
            options: {
              plugins: [
              ['import', { libraryName: 'antd', libraryDirectory: 'es', style: 'css' }],
              ],
            },
          },
          {
            options: {
              formatter: eslintFormatter,
              eslintPath: require.resolve('eslint'),
            },
            loader: require.resolve('eslint-loader'),
          },
        ],
        include: paths.appSrc,
      },
```

最后配置 sass-loader：

```js
          {
            // Exclude `js` files to keep "css" loader working as it injects
            // it's runtime that would otherwise processed through "file" loader.
            // Also exclude `html` and `json` extensions so they get processed
            // by webpacks internal loaders.
            exclude: [/\.js$/, /\.html$/, /\.json$/, /\.scss$/,],   // 在这里添加scss格式，让他不使用file-loader
            loader: require.resolve('file-loader'),
            options: {
              name: 'static/media/[name].[hash:8].[ext]',
            },
          },

          // 接着添加scss的配置内容
          {
            test: /\.scss$/,
            loaders: ['style-loader', 'css-loader', 'sass-loader'],
          },
```

至此，相关的配置内容都已经完成啦，以后有新的我再更新~

## React 生命周期以及相关概念

作为一个以前经常使用 Vue 的前段来说，其实感觉这两个框架的生命周期都有异曲同工之处。

相比较而言，React 的生命周期概念上较少，但是可操作性上要求更高。有不少的性能高优化可以从生命周期中来实现。

可以在 componentDidMount 中进行 ajax 的通信，可以在 shouldComponentUpdate 中进行性能的优化。

getDerivedStateFromProps()会在初始化和后续的更新中被调用。类似 Vue 中设置 immediately 的 watch，只不过 React 是相对于整体的 props，而 vue 的 watch 是监听单个对象。

### PureComponent

如果组件在给定相同的 props 和 states 下渲染的结果相同，那么就可以用 React.PureComponent 来代替 React.Component，但是 PureComponent 中是浅对比，如果对象中包含复杂的数据结构，那么如果要进行更新就必须更改复杂的数据结构的指针，或者使用不可变对象或者监听数据变化强制更新。比如 react-native 中的 FlatList，它便是一个 PureComponent。可以使用 concat 来触发更新。

### memo

memo 是一个新的组件，它会将 component 缓存到内存中，在下一次的使用中避免再次渲染。它使用的是函数式组件而非 class 式。它与 PureComponent 类似，给定相同的 state 和 props 会渲染相同的结果，而且通过浅对比来实施更新。不过你可以设置单独的对比函数作为 memo 的第二个参数。

### React.lazy、React.suspense

React.lazy 和 React.suspense 配合使用，可以给异步加载的组件一个 loading 提示框。给 React.suspense 添加 fallback 属性来添加 loading 提示框。

### Ref

每次在使用 ref 的时候可以好好考虑下是否真的需要使用 ref。有很多时候我们是可以传递 props 来替换 ref。

以后可能不需要创建 ref，但是现在需要调用 React.createRef Api 来创建 ref，使用 React.forwardRef 来传递 ref。
